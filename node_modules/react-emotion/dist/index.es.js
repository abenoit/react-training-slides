import { Component, createElement } from 'react';
import { memoize } from 'emotion-utils';
import { css, getRegisteredStyles } from 'emotion';
import * as emotion from 'emotion';
import PropTypes from 'prop-types';

var _contextTypes;

var channel = '__EMOTION_THEMING__';

var contextTypes = (_contextTypes = {}, _contextTypes[channel] = PropTypes.object, _contextTypes);

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/* global codegen */
function setTheme(theme) {
  this.setState({ theme: theme });
}

function componentWillMount() {
  if (this.context[channel] !== undefined) {
    this.unsubscribe = this.context[channel].subscribe(setTheme.bind(this));
  }
}
function componentWillUnmount() {
  if (this.unsubscribe !== undefined) {
    this.context[channel].unsubscribe(this.unsubscribe);
  }
}

var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|accept|acceptCharset|accessKey|action|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable)|(on[A-Z].*)|((data|aria)-.*))$/;
var testOmitPropsOnStringTag = memoize(function (key) {
  return reactPropsRegex.test(key);
});
var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
  return key !== 'theme' && key !== 'innerRef';
};
var testAlwaysTrue = function testAlwaysTrue() {
  return true;
};

var omitAssign = function omitAssign(testFn, target) {
  var i = 2;
  var length = arguments.length;
  for (; i < length; i++) {
    var source = arguments[i];
    var key = void 0;
    for (key in source) {
      if (testFn(key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};

var createStyled = function createStyled(tag, options) {
  if (process.env.NODE_ENV !== 'production') {
    if (tag === undefined) {
      throw new Error('You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.');
    }
  }
  var staticClassName = false;
  if (options !== undefined && options.e !== undefined) {
    staticClassName = options.e;
  }
  var isReal = tag.__emotion_real === tag;
  var baseTag = staticClassName === false ? isReal && tag.__emotion_base || tag : tag;

  var omitFn = typeof baseTag === 'string' ? testOmitPropsOnStringTag : testOmitPropsOnComponent;

  return function (strings) {
    for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      interpolations[_key - 1] = arguments[_key];
    }

    var styles = isReal && tag.__emotion_styles || [];
    if (staticClassName === false) {
      if (strings == null || strings.raw === undefined) {
        styles = styles.concat(strings, interpolations);
      } else {
        styles = interpolations.reduce(function (array, interp, i) {
          return array.concat(interp, strings[i + 1]);
        }, styles.concat(strings[0]));
      }
    }

    var Styled = function (_Component) {
      inherits(Styled, _Component);

      function Styled() {
        classCallCheck(this, Styled);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }

      Styled.prototype.render = function render() {
        var props = this.props,
            state = this.state;

        this.mergedProps = omitAssign(testAlwaysTrue, {}, props, {
          theme: state !== null && state.theme || props.theme || {}
        });

        var className = '';
        var classInterpolations = [];

        if (props.className) {
          if (staticClassName === false) {
            className += getRegisteredStyles(classInterpolations, props.className);
          } else {
            className += props.className + ' ';
          }
        }
        if (staticClassName === false) {
          className += css.apply(this, styles.concat(classInterpolations));
        } else {
          className += staticClassName;
        }

        return createElement(baseTag, omitAssign(omitFn, {}, props, { className: className, ref: props.innerRef }));
      };

      return Styled;
    }(Component);

    Styled.prototype.componentWillMount = componentWillMount;
    Styled.prototype.componentWillUnmount = componentWillUnmount;
    Styled.contextTypes = contextTypes;
    Styled.__emotion_styles = styles;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_real = Styled;

    Styled.displayName = 'Styled(' + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ')';

    Styled.withComponent = function (nextTag) {
      return createStyled(nextTag, options)(styles);
    };

    return Styled;
  };
};

export default createStyled;

export * from 'emotion';
//# sourceMappingURL=index.es.js.map
